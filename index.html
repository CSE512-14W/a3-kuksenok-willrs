<!DOCTYPE html>
<meta charset="utf-8">
<link rel="stylesheet" href="rsrcs/map.css" />
<style>

body, html {
  background: black;
  margin: 0;
  padding: 0;
}

#map {
  width: 500px;
  height: 500px;
  float:left;
}

div, svg {
  border:solid 1px red;
}

#barcharts{
  float:left;
  width:320px;
  padding-left:5px;
}

#barcharts svg {
  height:300px;
  width:100px;
  float:left;
}

#barcharts rect {
  fill: #555555;
}

#barcharts text {
  fill: white;
  font: 8px sans-serif;
  text-anchor: start;
}

#example{
  width:200px;
  color:#bbbbbb;
  padding:3px;
  padding-top:100px;
  float:left;
}

h1 {
  color:white;
}
</style>

<body>
<script src="http://d3js.org/d3.v3.min.js"></script>
<script src="http://d3js.org/queue.v1.min.js"></script>
<script src="http://d3js.org/topojson.v1.min.js"></script>
<script src="scripts/d3.geo.zoom.js"></script>
<!--
<script src="scripts/datamap.js"></script>
<script>

var map;

window.addEventListener('load', function() {
  var el = document.getElementById('map');
  map = new Datamap({
    element: document.getElementById('map'),
    fills: {
      defaultFill: '#333'
    },
    geographyConfig: {
      highlightOnHover: false,
      popupOnHover: false
    }
  });

  queue().defer(d3.json, 'data/ufo_metadata.json').await(bubble);
});

var bubble = function(error, ufos) {
  window.ufos = ufos;
  var locs = {};
  var bubbles = [];
  ufos.forEach(function(ufo) {
    if (!ufo[0] || ufo[0][0] === 0 || ufo[0][1] === 0 ||
        ufo[0][0] === undefined || ufo[0][1] === undefined) {
      return;
    }
    var key = ufo[0][0] + ',' + ufo[0][1]
    if (locs[key]) {
      bubbles[locs[key]].count += 1;
    } else {
      locs[key] = bubbles.length;
      bubbles.push({
        name: ufo[1],
        latitude: ufo[0][0],
        longitude: ufo[0][1],
        count: 1
      });
    }
  });
  bubbles.forEach(function(bubble) {
    bubble.radius = Math.sqrt(bubble.count);
  });
  map.bubbles(bubbles, {
    fillOpacity: 0.5,
    highlightBorderWidth: 1,
    borderWidth: 1,
    borderColor: "rgba(255, 255, 255, 0.5)"
  });
};

</script>
-->
<script src="scripts/map.js"></script>
<div id="vis-main">
  <div id='map'></div>
  <div id='barcharts'>
    <h1 id="label">X of Y UFOs selected. Z mention a missile launch.</h1>
    <svg id="summary"></svg>
    <svg id="shapes"></svg>
    <svg id="years"></svg>
  </div>
  <div id="example">
  </div>
</div>
<button onclick="reloadUfoSummaries()" >Trigger Reload</button>

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>
<script>
// This lists all the possible states for the example detail and related
// variables
window.example_detail_state_enum = {
    OFF : 0,
    CURRENT_SELECTION : 1,   // From a selection, weighted by length
    INDIVIDUAL : 2,   // From a selection, weighted by length
}
window.example_detail_state = window.example_detail_state_enum.OFF;

setInterval(function(){recurringExampleReloader()},10000);

function recurringExampleReloader() {
  if (window.example_detail_state == window.example_detail_state_enum.CURRENT_SELECTION) {
    var currentdate = new Date();

    var nextExample = "Fetch a new example here!" +currentdate.getMinutes() + ":" + currentdate.getSeconds();
    $('#example').animate({color : 'black'}, "slow", function(){
      $(this).text(nextExample).animate({color : 'white'});
    });
    //TODO this doesn't work, I'd like something smooth here....
  }
}

window.addEventListener('load', function() {
    queue().defer(d3.json, 'data/ufo_metadata.json').await(loadMetaData);
    queue().defer(d3.json, 'data/ufo_read_stats.json').await(loadReadStats);
});

window.total = 0;
window.total_summary = [];
window.total_shapes = [];
window.total_years = [];

var loadMetaData = function(error, ufos) {
  console.log("Loafing UFOs");
  window.total = ufos.length;
  var i = 0;
  total_shapes_dict = [];
  ufos.forEach(function(ufo) {
    var shape = ufo[4];
    if (shape == "" || shape == "unknown" || shape == "other" || shape == "undefined") {
      shape = "unknown / other";
    }
    if(total_shapes_dict[shape] == undefined){
      total_shapes_dict[shape] = 0;
    }
    total_shapes_dict[shape] ++;
  });
  window.total_shapes = keepTopX(total_shapes_dict, 20).sort(window.alphabetical_sort);
  console.log(window.total_shapes);
  loadUfos(ufos);
}
var loadReadStats = function(error, stats) {
  console.log(stats);
}

window.alphabetical_sort = function(a, b) {
    if(a.label < b.label) return -1;
    if(a.label > b.label) return 1;
    return 0;
}

function keepTopX(data_dict, x) {
  var values = [];
  console.log(data_dict);
  for (var label in data_dict) {
    values.push(data_dict[label]);
  }
  values.sort(function(a, b) { return b-a; });
  var cutoff = values[(values.length < x ? values.length : x) - 1];
  var resulting_data = [];
  for (var label in data_dict) {
    if(data_dict[label] >= cutoff && resulting_data.length<x) {
      resulting_data.push({"label":label, "value":data_dict[label]});
    }
  }
  return resulting_data;
}

// Fills in data for a UFO subset
function loadUfos(ufo_subset) {
  if (ufo_subset.length == window.total) {
    renderBarChart("#summary", window.total_summary);
    renderBarChart("#shapes", window.total_shapes);
    renderBarChart("#years", window.total_years); 
  } else {
      ufo_subset.forEach(function(ufo) {});
  }
}

function renderBarChart(which, data, subset) {
  console.log(data);
  console.log(data.size);
  var width = 100,
  barHeight = 10;

  var max = 0;
  for (var i in data) {
    if(data[i].value>max) {
      max = data[i].value;
    }
  }

  var x = d3.scale.linear()
      .domain([0, max]) //TOOD fix
      .range([0, width]);

  var chart = d3.select(which)
      .attr("width", width)
      .attr("height", barHeight * data.length);

  var bar = chart.selectAll("g")
      .data(data)
      .enter().append("g")
      .attr("transform", function(d, i) { return "translate(0," + i * barHeight + ")"; });
  //TODO subset here...
  bar.append("rect")
      .attr("width",  function(d) { return x(d.value); })
      .attr("height", barHeight - 1);

  bar.append("text")
      .attr("x", 3)
      .attr("y", barHeight / 2)
      .attr("dy", ".35em")
      .text(function(d, i) { return d.label + ": " + d.value; });

  //TODO add subset!

}


</script>
